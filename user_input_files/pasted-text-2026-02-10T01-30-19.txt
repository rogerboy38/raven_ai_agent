 Current symptom
Browser (Frappe UI / Raven frontend) connects to https://v2.sysmayal.cloud/socket.io/?EIO=4&transport=polling and receives a valid sid from the Engine.IO handshake.
​

Follow‑up requests with sid=... to /socket.io/?EIO=4&transport=polling&sid=... return HTTP 400 with body {"code":1,"message":"Session ID unknown"} both on localhost:9001 and via HTTPS.

WebSocket upgrade (wss://v2.sysmayal.cloud/socket.io/?EIO=4&transport=websocket&sid=...) fails with “WebSocket is closed before the connection is established” in the browser console.

So: the 400 is generated by Engine.IO itself, not by nginx or Traefik.
​

2. Environment summary
Backend framework: Frappe (ERPNext) with built‑in realtime using Socket.IO (file apps/frappe/socketio.js → require("./realtime")).

Realtime implementation: apps/frappe/realtime/index.js customizes Socket.IO: namespace io.of(/^\/.*$/), Redis pub/sub subscriber for cross‑process events, and HTTP server listening on socketio_port (UDS or TCP).

Node and packages (in /home/frappe/frappe-bench/apps/frappe):

socket.io@4.7.2 (server).
​

socket.io-client@4.7.2 (Frappe client).
​

@socket.io/redis-adapter@7.2.0 and redis@5.10.0 installed but not yet wired into realtime/index.js (Frappe currently uses Redis only as a subscriber, not as Socket.IO adapter).

Custom orchestration script: start_v3.sh

Starts three Redis instances (queue, socketio, cache) on ports 11000/12000/13000 (all PONG OK).
​

Starts Socket.IO: /home/frappe/.nvm/versions/node/v24.12.0/bin/node apps/frappe/socketio.js > logs/socketio.log 2>&1 &.

Starts Frappe web server: bench serve --port 8000 --site v2.sysmayal.cloud > logs/web.log 2>&1 &.

Runs an internal check: curl http://localhost:9001/socket.io/?EIO=4 → currently returns HTTP 400 from the script, but a direct call with full query ?EIO=4&transport=polling returns 200 + sid.
​

Additional test server: test-sio.js (simple Socket.IO server on port 9100) shows the same pattern when called with curl (200 on handshake, 400 “Session ID unknown” if the second request is not shaped like a real Engine.IO client request), so Engine.IO itself is behaving per spec.

3. Likely root causes
From Socket.IO’s own troubleshooting docs, "Session ID unknown" (code 1) appears when the server does not recognize the sid in the follow‑up polling/WebSocket upgrade. In practice that happens when:

Requests of the same Socket.IO session are routed to different Node processes (multi‑instance without sticky sessions).

The server process is restarted between handshake and subsequent requests.

The second request is malformed (missing required params, wrong path, or missing cookies/headers) and Engine.IO cannot map it back to an existing session.

Given this setup:

There is a single Node process (apps/frappe/socketio.js) for Socket.IO, so multi‑instance routing is unlikely at the Node level.
​

The issue reproduces even when hitting http://localhost:9001 directly, so Traefik and nginx are not the primary cause.
​

The Frappe realtime code uses io.of(/^\/.*$/) and an authentication middleware, which means namespace and auth logic must accept the incoming namespace and not reject/close the connection after the handshake.

The most probable technical issues to investigate in Raven/Frappe integration are:

Client transport mismatch / fallback loop
The Frappe/Raven frontend may be trying ['websocket','polling'] or similar; if WebSocket upgrade fails or proxies interfere, the client might reconnect with a new sid while the server cleans up the previous one, triggering repeated “Session ID unknown” errors.

Namespace or auth behavior in realtime/index.js
Frappe’s realtime uses dynamic namespaces (io.of(/^\/.*$/)) and a custom authenticate middleware that validates the site and user. If the middleware throws or disconnects the socket after the first request, the engine will drop the session and the next polling will see an unknown sid.

Custom Raven client implementation
Raven appears to be a separate app that connects to Frappe’s Socket.IO endpoint from a different origin or custom path. Any mismatch in:
​

path (must be exactly /socket.io/),

withCredentials and cookies,

or transport options

can cause Engine.IO to treat follow‑up requests as belonging to a different context than the one where the session was created.

4. Technical requirements for the Raven Socket.IO client
The Raven frontend/client should conform to these requirements when connecting to Frappe’s Socket.IO endpoint:

Server URL and path

ts
const socket = io("https://v2.sysmayal.cloud", {
  path: "/socket.io/",
});
Do not connect directly to localhost:9001 from the browser; use the public HTTPS origin behind Traefik.
​

Make sure Traefik and nginx forward /socket.io/ without path rewriting and preserve query parameters.
​

Transports configuration

For debugging and to avoid polling issues, Raven’s client should temporarily force WebSocket only:

ts
const socket = io("https://v2.sysmayal.cloud", {
  path: "/socket.io/",
  transports: ["websocket"], // temporary
  withCredentials: true,
});
Socket.IO maintainers note that Session ID unknown often disappears when using pure WebSocket, especially behind proxies, because polling is more sensitive to path/affinity issues.

Once stable, you can expand:

ts
transports: ["polling", "websocket"],
but keep WebSocket as the preferred transport.

Credentials and session

Raven must send cookies and any auth tokens consistently:

ts
const socket = io("https://v2.sysmayal.cloud", {
  path: "/socket.io/",
  transports: ["websocket"],
  withCredentials: true,
  auth: {
    // optionally forward Frappe user/session info if needed
    // e.g. sessionId, api key, etc.
  },
});
Frappe realtime typically authenticates based on the HTTP cookies and CSRF token of the logged‑in user.

If Raven is running in a different origin, CORS must allow that origin and cookies must still be sent (withCredentials: true + server CORS headers).
​

Reconnect behavior

Raven’s client should handle reconnects without creating multiple overlapping connections that may confuse the server:

ts
const socket = io("https://v2.sysmayal.cloud", {
  path: "/socket.io/",
  transports: ["websocket"],
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
});
Ensure you are not instantiating multiple io() connections per tab for the same user/site, which can increase churn and sid rotation.

5. Technical requirements for the Frappe Socket.IO server (realtime module)
The team should validate and, if needed, adjust the server implementation under apps/frappe/realtime/index.js:

Engine.IO path and options

Confirm the Server is created as:

js
const server = http.createServer();

const io = new Server(server, {
  cors: {
    origin: true,
    credentials: true,
  },
  cleanupEmptyChildNamespaces: true,
  path: "/socket.io", // important: matches client path; no trailing slash
});
path must exactly match the client’s path option and Traefik/nginx proxy rules.
​

Keep cleanupEmptyChildNamespaces: true unless there is a documented reason to change it.

Namespaces and authentication

Frappe uses:

js
const realtime = io.of(/^\/.*$/);
const authenticate = require("./middlewares/authenticate");
realtime.use(authenticate);
The Raven team should ensure:

authenticate does not silently terminate the socket or throw unhandled exceptions after the initial handshake. Any rejection should be explicit and logs should show why.

The namespace used by Raven (most likely "/<sitename>", for example /v2.sysmayal.cloud) is correctly handled by authenticate and not closed after first packet.

Redis adapter (future scaling)

If Raven or Frappe needs to scale Socket.IO across multiple Node processes behind Traefik, you must:

js
const { createAdapter } = require("@socket.io/redis-adapter");
const { createClient } = require("redis");

const pubClient = createClient({ url: process.env.SOCKETIO_REDIS_URL });
const subClient = pubClient.duplicate();
await pubClient.connect();
await subClient.connect();
io.adapter(createAdapter(pubClient, subClient));
And enable sticky sessions in Traefik, otherwise "Session ID unknown" will appear when a given sid hits a different Node instance than the one that created it.

Right now there is only one Node process, so this is optional, but the adapter is already installed.

Logging and debug

For reproducible debugging, the team should be able to run:

bash
DEBUG=engine:socket,engine:transport,socket.io:* node apps/frappe/socketio.js
And capture when the server logs:

Session creation (handshake).

Session close or cleanup.

Any “unknown sid” events.

This will confirm whether the server itself is closing sessions early or whether the issue stems from proxies.

6. Proxy and routing requirements (Traefik + nginx)
Even though the error is reproducible on localhost, Raven will depend on correct proxy behavior in production:

nginx (frappe-socketio container)

Minimal, conformant config:

text
events { worker_connections 1024; }

http {
  upstream socketio_backend {
    server 172.17.0.1:9001; # host.docker / bench host
  }

  server {
    listen 80;

    location /socket.io/ {
      proxy_pass http://socketio_backend;
      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;
      proxy_read_timeout 86400;
      proxy_send_timeout 86400;
      proxy_buffering off;
      proxy_cache off;
    }
  }
}
Path /socket.io/ must be forwarded unchanged (no extra slash, no rewrite to /).

Traefik

Labels (conceptually):

text
- "traefik.enable=true"
- "traefik.http.routers.socketio.rule=Host(`v2.sysmayal.cloud`) && PathPrefix(`/socket.io`)"
- "traefik.http.routers.socketio.entrypoints=websecure"
- "traefik.http.routers.socketio.tls.certresolver=myresolver"
- "traefik.http.services.socketio.loadbalancer.server.port=80"
Requirements:

No stripPrefix or path rewrite in the middleware chain; /socket.io/... must reach nginx as /socket.io/....
​

For multi‑container setups, enable cookie‑based sticky sessions in Traefik so all requests of a given Socket.IO session go to the same backend server.

7. Actionable checklist for the Raven team
Client (Raven)

Ensure the client uses:

ts
io("https://v2.sysmayal.cloud", {
  path: "/socket.io/",
  transports: ["websocket"],
  withCredentials: true,
});
Verify in browser DevTools → Network that all socket.io/ requests:

Hit https://v2.sysmayal.cloud/socket.io/....

Preserve the same sid across polling and websocket upgrade.

Do not get 400 on the first polling after handshake.

Server (Frappe realtime)

Confirm Server initialization options include path: "/socket.io" and CORS with credentials.

Review authenticate middleware under realtime/middlewares/authenticate to ensure it does not close sockets after authentication.

Add debug logging around realtime.on("connection", on_connection) and any custom Raven handlers to ensure no code is calling socket.disconnect() or io.close() unexpectedly.

Deployment

Confirm nginx and Traefik configs meet the path and header requirements above.

If you ever run multiple Socket.IO Node processes for Raven, add the Redis adapter and sticky sessions.